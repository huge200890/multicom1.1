#!/usr/bin/perl -w
########################################################################
#Check pir file generated by hhpred against the hhpred protein database
#Change both pir file and pdb file to make them consistent if necessary
#Input: pdb database dir, pir file, output pir file, output dir
#Output: a modified pir file, modified pdb files in output dir
#Author: Jianlin Cheng
#Date: 6/25/2009
########################################################################

if (@ARGV != 4)
{
	die "need four parameters: hhpred pdb database dir, pir file, output pirfile, output dir.\n";
}

$pdb_dir = shift @ARGV;

use Cwd 'abs_path';
$pdb_dir = abs_path($pdb_dir);
-d $pdb_dir || die "can't find $pdb_dir.\n";

$pir_file = shift @ARGV;
$pir_file = abs_path($pir_file);
-f $pir_file || die "can't find $pir_file.\n";

$out_file = shift @ARGV;

$out_dir = shift @ARGV;
-d $out_dir || `mkdir $out_dir`; 

open(PIR, $pir_file) || die "can't read $pir_file.\n";
@pir = <PIR>;
close PIR; 

$qalign = pop @pir; 
$qinfo = pop @pir;
$qtitle = pop @pir;
$qcomm = pop @pir; 

##############standard Amino Acids (3 letter <-> 1 letter)#######
%amino=();
$amino{"ALA"} = 'A';
$amino{"CYS"} = 'C';
$amino{"ASP"} = 'D';
$amino{"GLU"} = 'E';
$amino{"PHE"} = 'F';
$amino{"GLY"} = 'G';
$amino{"HIS"} = 'H';
$amino{"ILE"} = 'I';
$amino{"LYS"} = 'K';
$amino{"LEU"} = 'L';
$amino{"MET"} = 'M';
$amino{"ASN"} = 'N';
$amino{"PRO"} = 'P';
$amino{"GLN"} = 'Q';
$amino{"ARG"} = 'R';
$amino{"SER"} = 'S';
$amino{"THR"} = 'T';
$amino{"VAL"} = 'V';
$amino{"TRP"} = 'W';
$amino{"TYR"} = 'Y';
###################################################################

open(PIR, ">$out_file") || die "can't create $out_file.\n";

while (@pir)
{
	$t_comment = shift @pir;
	$t_title = shift @pir;
	$t_info = shift @pir;
	$t_align = shift @pir;
	shift @pir; 

	#print "title: $t_title\n";
	@fields = split(/;/, $t_title); 
	@fields = split(/:/, $t_info);
	$t_start = $fields[2]; 
	$t_name = $fields[1];
#	$t_end = $fields[4]; 

	$t_file = "$pdb_dir/$t_name.pdb";	
	
	if (! open(ATOM, $t_file))
	{
		warn "can't read $t_file. skip.\n";
		next;
	}


	@atoms = <ATOM>;
	close ATOM; 
	
	#construct a list of amino acids, original indices, and new orders (starting from 1)
	print "process template $t_name...\n";
	@amino_acids = ();
	@org_positions = ();
	%pos2order = (); 
	@records = (); 
	#@new_orders = (); 
	#@states = (); #known or unknown

	my $prev = -1;

	$count = 0; 
	while (@atoms)
	{
		my $text = shift @atoms;
		if ($text =~ /^ATOM/)
		{
			push @records, $text; 	
			#get aa name
			#get position
			my $res = substr($text, 17, 3); 
			$res = uc($res); 
			$res =~ s/\s+//g;
			my $pos = substr($text, 22, 4);

			#if 3-letter, convert it to 1-letter.
			if (length($res) == 3)
			{
				if (exists($amino{$res}) )
				{
					$res = $amino{$res}; 
				}
				else
				{
					$res = "X"; 
					print "$t_file: resudie is unknown, shouldn't happen.\n"; 
				}
			}

			$pos = int($pos);
	#		print "pos = *$pos$\n";
			if ($pos != $prev)
			{
				push @amino_acids, $res;
				push @org_positions, $pos;

				if ($res ne "X")
				{
					$count++; 
					$pos2order{"$pos"} = $count; 
				}
				else
				{
					$pos2order{"$pos"} = -1; 
				}
			
				$prev = $pos; 	
			}
		}
	}



	#compare the amino acids in template alignment with template atom records
	$t_align_len =	length($t_align); 
	$t_align_len -= 2; #not count "*" and new line

	$new_t_align = "";	

	$org_index = $t_start; 
	$first_org_index = -1;
	$last_org_index = -1; 
	for ($i = 0; $i < $t_align_len; $i++)
	{
		$aa = substr($t_align, $i, 1); 

		if ($aa ne "-")
		{
			#check if aa is found in atom file  
			$found = 0; 
			for ($j = 0; $j < @org_positions; $j++)
			{
				if ($org_positions[$j] == $org_index && $amino_acids[$j] eq $aa)
				{
					$found = 1; 
					last;
				}		
			}

			if ($found == 1)
			{
				$new_t_align .= $aa; 
				if ($first_org_index < 0)
				{
					$first_org_index = $org_index; 	
				}
				$last_org_index = $org_index; 
			}
			else
			{
				$new_t_align .= "-";
			}
			$org_index++; 

		}
		else
		{
			$new_t_align .= "-"; 
		}
	} 
	$new_t_align .= "*\n";

	#process atom file

	$new_atom_file = "$out_dir/$t_name.pdb";

	open(ATOM, ">$new_atom_file") || die "can't create $new_atom_file.\n";

	while (@records)
	{
		my $text = shift @records;
		my $res = substr($text, 17, 3); 
		$res = uc($res); 
		$res =~ s/\s+//g;
		my $pos = substr($text, 22, 4);

		#get the new position
		$pos = int($pos); 
		$order = $pos2order{"$pos"};
		if ($order > 0)
		{
			#use new position for the record
			$pos_len = length($order);
			if ($pos_len == 3)
			{
				$order = " $order";
			}					
			elsif ($pos_len == 2)
			{
				$order = "  $order";
			}
			elsif ($pos_len == 1)
			{
				$order = "   $order";
			}

			$new_text = substr($text, 0, 22) . $order . substr($text, 26); 

			print ATOM $new_text;
		}

	}

	close ATOM; 

	#@valid_pos = sort keys %pos2order;
	#print "Valid positions: ", join(" ", @valid_pos), "\n";

	#foreach $key (@valid_pos)
	#{
	#	print "$key -> $pos2order{$key}\n";
	#}

	$first_org_index = int($first_org_index);
	$last_org_index = int($last_org_index);


	if (! exists $pos2order{"$first_org_index"})
	{
		warn "Order of the position $first_org_index is not found. Skip $t_title\n";
		next;
	}
	if (! exists $pos2order{"$last_org_index"})
	{
		warn "Order of the position $last_org_index is not found. Skip $t_title\n";
		next;
	}

	$new_start = $pos2order{"$first_org_index"};
	$new_end = $pos2order{"$last_org_index"}; 

	@fields = split(/:/, $t_info);
	$fields[2] = $new_start;
	$fields[4] = $new_end;	

	print "start ($first_org_index), end ($last_org_index): $new_start - $new_end\n";

	$t_new_info = join(":", @fields); 

	print PIR "$t_comment$t_title$t_new_info$new_t_align\n";
}

print PIR "$qcomm$qtitle$qinfo$qalign";
close PIR; 


