#!/usr/bin/perl -w
########################################################################
#Check pir file generated by hhpred against the hhpred protein database
#Change both pir file and pdb file to make them consistent if necessary
#Input: pdb database dir, pir file, output pir file, output dir
#Output: a modified pir file, modified pdb files in output dir
#Author: Jianlin Cheng
#Date: 6/25/2009
#Update: 2/23/2014
#adjust the start and end position in pir file based on pdb file
########################################################################

if (@ARGV != 3)
{
	die "need three parameters: hhpred pdb database dir, pir file, output pirfile.\n";
}

$pdb_dir = shift @ARGV;

use Cwd 'abs_path';
$pdb_dir = abs_path($pdb_dir);
-d $pdb_dir || die "can't find $pdb_dir.\n";

$pir_file = shift @ARGV;
$pir_file = abs_path($pir_file);
-f $pir_file || die "can't find $pir_file.\n";

$out_file = shift @ARGV;

open(PIR, $pir_file) || die "can't read $pir_file.\n";
@pir = <PIR>;
close PIR; 

$qalign = pop @pir; 
$qinfo = pop @pir;
$qtitle = pop @pir;
$qcomm = pop @pir; 

##############standard Amino Acids (3 letter <-> 1 letter)#######
%amino=();
$amino{"ALA"} = 'A';
$amino{"CYS"} = 'C';
$amino{"ASP"} = 'D';
$amino{"GLU"} = 'E';
$amino{"PHE"} = 'F';
$amino{"GLY"} = 'G';
$amino{"HIS"} = 'H';
$amino{"ILE"} = 'I';
$amino{"LYS"} = 'K';
$amino{"LEU"} = 'L';
$amino{"MET"} = 'M';
$amino{"ASN"} = 'N';
$amino{"PRO"} = 'P';
$amino{"GLN"} = 'Q';
$amino{"ARG"} = 'R';
$amino{"SER"} = 'S';
$amino{"THR"} = 'T';
$amino{"VAL"} = 'V';
$amino{"TRP"} = 'W';
$amino{"TYR"} = 'Y';
###################################################################

open(PIR, ">$out_file") || die "can't create $out_file.\n";

$is_adjusted = 0; 

while (@pir)
{
	$t_comment = shift @pir;
	$t_title = shift @pir;
	$t_info = shift @pir;
	$t_align = shift @pir;
	shift @pir; 

	#print "title: $t_title\n";
	@fields = split(/;/, $t_title); 
	@fields = split(/:/, $t_info);
	$t_start = $fields[2]; 
	$t_name = $fields[1];
#	$t_end = $fields[4]; 

	$t_file = "$pdb_dir/$t_name.pdb";	
	
	if (! open(ATOM, $t_file))
	{
		warn "can't read $t_file. skip.\n";
		next;
	}


	@atoms = <ATOM>;
	close ATOM; 
	
	#construct a list of amino acids, original indices, and new orders (starting from 1)
	print "process template $t_name...\n";
	@amino_acids = ();
	@org_positions = ();
	%pos2order = (); 
	@records = (); 
	#@new_orders = (); 
	#@states = (); #known or unknown

	my $prev = -1;

	$count = 0; 
	while (@atoms)
	{
		my $text = shift @atoms;
		if ($text =~ /^ATOM/)
		{
			push @records, $text; 	
			#get aa name
			#get position
			my $res = substr($text, 17, 3); 
			$res = uc($res); 
			$res =~ s/\s+//g;
			my $pos = substr($text, 22, 4);

			#if 3-letter, convert it to 1-letter.
			if (length($res) == 3)
			{
				if (exists($amino{$res}) )
				{
					$res = $amino{$res}; 
				}
				else
				{
					$res = "X"; 
					print "$t_file: resudie is unknown, shouldn't happen.\n"; 
				}
			}

			$pos = int($pos);
	#		print "pos = *$pos$\n";
			if ($pos != $prev)
			{
				push @amino_acids, $res;
				push @org_positions, $pos;

				if ($res ne "X")
				{
					$count++; 
					$pos2order{"$pos"} = $count; 
				}
				else
				{
					$pos2order{"$pos"} = -1; 
				}
			
				$prev = $pos; 	
			}
		}
	}


	$pdb_seq = join("", @amino_acids); 

	#figure out the exact start and end positions of template sequence
	$temp_seq = $t_align;
	chomp $temp_seq;
	#chop off *
	chop $temp_seq; 
	$temp_seq =~ s/-//g;
	
	$shorten_len = 0; 
	if (length($temp_seq) > length($pdb_seq))
	{
		$shorten_len = length($temp_seq) - length($pdb_seq); 

		#calculate the number of different residues at the begining of the sequence.
		$diff_count = 0;
		$half_temp_seq = substr($temp_seq, 0, int(length($temp_seq)/2)); 
		$diff_count = index($pdb_seq, $half_temp_seq);
		if ($diff_count	> 0)
		{
			$shorten_len += $diff_count;
		}
			

		$temp_seq = substr($temp_seq, 0, length($pdb_seq) - $diff_count); 
		warn "template sequence length is longer than pdb sequence length. shorten it by $shorten_len\n";
	}	
	
	$begin_index = index($pdb_seq, $temp_seq);
	if ($begin_index >= 0)
	{
		$is_adjusted = 1; 
		print "$pdb_seq\n";
		print "$temp_seq\n";
		print "begin index: $begin_index\n";
		$begin_pos = $org_positions[$begin_index]; 	
		$end_pos = $begin_pos + length($temp_seq) - 1; 

		@fields = split(/:/, $t_info);
		$fields[2] = $begin_pos;
		$fields[4] = $end_pos;	

		print "Adjustment of location is: ", $begin_pos - $t_start, "\n";

		$t_new_info = join(":", @fields); 
		
		if ($shorten_len > 0)
		{
			$t_align_adjust = "";
			$res_count = 0; 
			for ($ii = 0; $ii < length($t_align); $ii++)
			{
				$cur_letter = substr($t_align, $ii, 1);								
				if ($cur_letter eq "*")
				{
					$t_align_adjust .= $cur_letter; 	
				}
				elsif ($cur_letter eq "\n")
				{
					$t_align_adjust .= $cur_letter; 	
				}
				elsif ($cur_letter ne "-" && $res_count < length($pdb_seq))
				{
					$t_align_adjust .= $cur_letter; 	
					$res_count++; 
				}
				else
				{
					$t_align_adjust .= "-"; 		
				}
			}
			$t_align = $t_align_adjust; 
		}

		print PIR "$t_comment$t_title$t_new_info$t_align\n";
	}
	else
	{
		print "PDB: $pdb_seq\n";
		print "TMP: $temp_seq\n";
		warn "The template sequence is not found in the pdb file. skip.\n";	
	}
}

print PIR "$qcomm$qtitle$qinfo$qalign";
close PIR; 

if ($is_adjusted == 0)
{
	print "Not index adjustment is made. The orginal pir file is copied to the output file\n";
	`cp $pir_file $out_file`; 
}


